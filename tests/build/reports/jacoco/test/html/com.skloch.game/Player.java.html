<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Player.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">com.skloch.game</a> &gt; <span class="el_source">Player.java</span></div><h1>Player.java</h1><pre class="source lang-java linenums">package com.skloch.game;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector3;
import com.badlogic.gdx.utils.Array;

// Changes
//
// - Added running by implementing, running_speed, runningAnimation, new keybind checks for Shift key, and the new isRunning() function
//

/**
 * A class handling everything needed to control and draw a player, including animation, movement and collision
 */
public class Player {
    // Hitboxes
    public Rectangle sprite, feet, eventHitbox;
    public float centreX, centreY;
<span class="nc" id="L24">    public int direction = 2; // 0 = up, 1 = right, 2 = down, 3 = left (like a clock)</span>
    private TextureRegion currentFrame;
<span class="nc" id="L26">    private float stateTime = 0;</span>
    private final Array&lt;Animation&lt;TextureRegion&gt;&gt; walkingAnimation, idleAnimation, runningAnimation;
    // Stats
<span class="nc" id="L29">    public float speed = 300f;</span>
<span class="nc" id="L30">    public float running_speed = 400f;</span>
    public Array&lt;GameObject&gt; collidables;
<span class="nc" id="L32">    public int scale = 4;</span>
    private Rectangle bounds;
    private GameObject closestObject;
    public boolean frozen, moving, running;

    /**
     * A player character, contains methods to move the player and update animations, also includes collision handling
     * and can be used to trigger events of objects near the player.
     * Includes a feet hitbox for collision and an event hitbox for triggering objects.
     * Call move() then draw the result of getCurrentAnimation() to use
     *
     * @param avatar &quot;avatar1&quot; for the more masculine character, &quot;avatar2&quot; for the more feminine character,
     *               player animations are packed in the player_sprites atlas
     */
<span class="nc" id="L46">    public Player (String avatar) {</span>
        // Load the player's textures from the atlas
<span class="nc" id="L48">        TextureAtlas playerAtlas = new TextureAtlas(Gdx.files.internal(&quot;Sprites/Player/player_sprites.atlas&quot;));</span>

<span class="nc" id="L50">        walkingAnimation = new Array&lt;Animation&lt;TextureRegion&gt;&gt;();</span>
<span class="nc" id="L51">        idleAnimation = new Array&lt;Animation&lt;TextureRegion&gt;&gt;();</span>
<span class="nc" id="L52">        runningAnimation = new Array&lt;Animation&lt;TextureRegion&gt;&gt;();</span>

        // Load walking animation from Sprite atlas
<span class="nc" id="L55">        walkingAnimation.add(</span>
<span class="nc" id="L56">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_back&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L57">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_right&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L58">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_front&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L59">                new Animation&lt;TextureRegion&gt;(0.25f, playerAtlas.findRegions(avatar + &quot;_walk_left&quot;), Animation.PlayMode.LOOP));</span>
<span class="nc" id="L60">        runningAnimation.add(</span>
<span class="nc" id="L61">                new Animation&lt;TextureRegion&gt;(0.1f, playerAtlas.findRegions(avatar + &quot;_walk_back&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L62">                new Animation&lt;TextureRegion&gt;(0.1f, playerAtlas.findRegions(avatar + &quot;_walk_right&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L63">                new Animation&lt;TextureRegion&gt;(0.1f, playerAtlas.findRegions(avatar + &quot;_walk_front&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L64">                new Animation&lt;TextureRegion&gt;(0.1f, playerAtlas.findRegions(avatar + &quot;_walk_left&quot;), Animation.PlayMode.LOOP));</span>
        // Load idle animation
<span class="nc" id="L66">        idleAnimation.add(</span>
<span class="nc" id="L67">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_back&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L68">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_right&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L69">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_front&quot;), Animation.PlayMode.LOOP),</span>
<span class="nc" id="L70">                new Animation&lt;TextureRegion&gt;(0.40f, playerAtlas.findRegions(avatar + &quot;_idle_left&quot;), Animation.PlayMode.LOOP)</span>
        );

<span class="nc" id="L73">        collidables = new Array&lt;GameObject&gt;();</span>

        // Sprite is a rectangle covering the whole player
<span class="nc" id="L76">        sprite = new Rectangle(0, 0, 17*scale, 28*scale);</span>

        // Feet is a rectangle just covering the player's feet, so is better for collision
<span class="nc" id="L79">        feet = new Rectangle(4*scale, 0, 9*scale, 7*scale);</span>

        // Hitbox for triggering events with objects
<span class="nc" id="L82">        float hitboxScaleX = 2.2f;</span>
<span class="nc" id="L83">        float hitboxScaley = 1.7f;</span>
<span class="nc" id="L84">        eventHitbox = new Rectangle(</span>
<span class="nc" id="L85">                sprite.getX() - (sprite.getWidth()*hitboxScaleX - sprite.getWidth()) / 2,</span>
<span class="nc" id="L86">                sprite.getY() - (sprite.getHeight()*hitboxScaley - sprite.getHeight()) / 2,</span>
<span class="nc" id="L87">                sprite.getWidth()*hitboxScaleX,</span>
<span class="nc" id="L88">                sprite.getHeight()*hitboxScaley</span>
        );

<span class="nc" id="L91">    }</span>

    /**
     * Handles all the logic involved in moving the player given keyboard inputs
     * If the player encounters an object, they will not be alowed to move into the space, but will attempt to
     * 'slide' off of it.
     * Also updates the player's animation
     *
     * &lt;p&gt;&lt;/p&gt;
     *
     * Also locates the nearest object after moving, which can be used to trigger events
     *
     * @param delta The time passed since the previous render
     */
    public void move (float delta) {
        // Updates the player's position based on keys being pressed
        // Also updates the direction they are facing, and whether they are currently moving
        // And also does collision

<span class="nc" id="L110">        moving = false;</span>
        // To check collision, store the player's current position
<span class="nc" id="L112">        float oldX = sprite.x;</span>
<span class="nc" id="L113">        float oldY = sprite.y;</span>
<span class="nc" id="L114">        float oldFeetX = feet.x;</span>

        // If not frozen, react to keyboard input presses
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (!frozen) {</span>
            // Move the player and their 2 other hitboxes
<span class="nc" id="L119">            moving = false;</span>
<span class="nc" id="L120">            running = false;</span>
<span class="nc bnc" id="L121" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.LEFT) || Gdx.input.isKeyPressed(Input.Keys.A)) {</span>
<span class="nc" id="L122">                this.setX(sprite.getX() - speed * delta); // Note: Setting all the values with a constant delta removes hitbox desyncing issues</span>
<span class="nc" id="L123">                direction = 3;</span>
<span class="nc" id="L124">                moving = true;</span>
<span class="nc bnc" id="L125" title="All 4 branches missed.">                if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT)) {</span>
<span class="nc" id="L126">                    this.setX(sprite.getX() - running_speed * delta); // Note: Setting all the values with a constant delta removes hitbox desyncing issues</span>
<span class="nc" id="L127">                    running = true;</span>
                }
            }
<span class="nc bnc" id="L130" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.RIGHT) || Gdx.input.isKeyPressed(Input.Keys.D)) {</span>
<span class="nc" id="L131">                this.setX(sprite.getX() + speed * delta);</span>
<span class="nc" id="L132">                direction = 1;</span>
<span class="nc" id="L133">                moving = true;</span>
<span class="nc bnc" id="L134" title="All 4 branches missed.">                if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT)) {</span>
<span class="nc" id="L135">                    this.setX(sprite.getX() + running_speed * delta);</span>
<span class="nc" id="L136">                    running = true;</span>
                }
            }
<span class="nc bnc" id="L139" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.UP) || Gdx.input.isKeyPressed(Input.Keys.W)) {</span>
<span class="nc" id="L140">                this.setY(sprite.getY() + speed * delta);</span>
<span class="nc" id="L141">                direction = 0;</span>
<span class="nc" id="L142">                moving = true;</span>
<span class="nc bnc" id="L143" title="All 4 branches missed.">                if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT)) {</span>
<span class="nc" id="L144">                    this.setY(sprite.getY() + running_speed * delta);</span>
<span class="nc" id="L145">                    running = true;</span>
                }
            }
<span class="nc bnc" id="L148" title="All 4 branches missed.">            if (Gdx.input.isKeyPressed(Input.Keys.DOWN) || Gdx.input.isKeyPressed(Input.Keys.S)) {</span>
<span class="nc" id="L149">                this.setY(sprite.getY() - speed * delta);</span>
<span class="nc" id="L150">                direction = 2;</span>
<span class="nc" id="L151">                moving = true;</span>
<span class="nc bnc" id="L152" title="All 4 branches missed.">                if (Gdx.input.isKeyPressed(Input.Keys.SHIFT_LEFT) || Gdx.input.isKeyPressed(Input.Keys.SHIFT_RIGHT)) {</span>
<span class="nc" id="L153">                    this.setY(sprite.getY() - running_speed * delta);</span>
<span class="nc" id="L154">                    running = true;</span>
                }
            }

            // Check if the player's feet are inside an object, if they are, move them back in that axis
<span class="nc bnc" id="L159" title="All 2 branches missed.">            for (GameObject object : this.collidables) {</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">                if (feet.overlaps(object)) {</span>
                    // Find the direction that the player needs to be moved back to
                    // Reset x
<span class="nc bnc" id="L163" title="All 4 branches missed.">                    if (!(oldFeetX &lt; object.x + object.width &amp;&amp; oldFeetX + feet.width &gt; object.x)) {</span>
<span class="nc" id="L164">                        this.setX(oldX);</span>
                    }
                    // If overlapping in y direction
<span class="nc bnc" id="L167" title="All 4 branches missed.">                    if (!(oldY &lt; object.y + object.height &amp;&amp; oldY + feet.height &gt; object.y)) {</span>
<span class="nc" id="L168">                        this.setY(oldY);</span>
                    }
                    // The above two are essentially the same code as Rectangle.overlaps()
                    // Just separated into the x and y dimensions
                }
<span class="nc" id="L173">            }</span>


            // Check the player is in bounds
<span class="nc bnc" id="L177" title="All 2 branches missed.">            if (bounds != null) {</span>
                // If player is out of bounds, move them back
<span class="nc bnc" id="L179" title="All 2 branches missed.">                if (feet.getX() &lt; bounds.getX()) {</span>
<span class="nc" id="L180">                    sprite.x = bounds.getX()-4*scale;</span>
<span class="nc" id="L181">                    feet.x = sprite.x + 4*scale;</span>
                }
<span class="nc bnc" id="L183" title="All 2 branches missed.">                if (feet.getX()+feet.getWidth() &gt; bounds.getWidth()) {</span>
<span class="nc" id="L184">                    sprite.x = (bounds.getWidth() - feet.getWidth()) - (4*scale);</span>
<span class="nc" id="L185">                    feet.x = sprite.x + 4*scale;</span>
                }
<span class="nc bnc" id="L187" title="All 2 branches missed.">                if (feet.getY() &lt; bounds.getY()) {</span>
<span class="nc" id="L188">                    sprite.y = bounds.getY();</span>
<span class="nc" id="L189">                    feet.y = bounds.getY();</span>
                }
<span class="nc bnc" id="L191" title="All 2 branches missed.">                if (feet.getY()+feet.getHeight() &gt; bounds.getHeight()) {</span>
<span class="nc" id="L192">                    sprite.y = bounds.getHeight()-feet.getHeight();</span>
<span class="nc" id="L193">                    feet.y = sprite.y;</span>
                }
            }
        }



        // Find the closest object to the player so they can interact with it
<span class="nc" id="L201">        recalcCentre(); // Just recalculates the centre of the player now we have moved them</span>
<span class="nc" id="L202">        float distance = -1;</span>
<span class="nc" id="L203">        closestObject = null;</span>
<span class="nc bnc" id="L204" title="All 2 branches missed.">        for (GameObject object : this.collidables) {</span>
            // Check if this object is even interactable
<span class="nc bnc" id="L206" title="All 4 branches missed.">            if (object.get(&quot;event&quot;) != null || object.get(&quot;text&quot;) != null) {</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">                if (eventHitbox.overlaps(object)) {</span>
                    // Check if this is the closest object to the player
<span class="nc bnc" id="L209" title="All 4 branches missed.">                    if (distance == -1 || distanceFrom(object) &lt; distance) {</span>
<span class="nc" id="L210">                        closestObject = object;</span>
<span class="nc" id="L211">                        distance = distanceFrom(object);</span>
                    }
                }
            }
<span class="nc" id="L215">        }</span>

        // Increment the animation
<span class="nc" id="L218">        updateAnimation();</span>

<span class="nc" id="L220">    }</span>

    /**
     * Advances the current animation based on the time since the last render
     * The animation frame of the player can be grabbed with getCurrentFrame
     */
    public void updateAnimation() {
<span class="nc" id="L227">        stateTime += Gdx.graphics.getDeltaTime();</span>
        // Set the current frame of the animation
        // Show a different animation if the player is moving vs idling
<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (running) {</span>
<span class="nc" id="L231">            currentFrame = runningAnimation.get(direction).getKeyFrame(stateTime);</span>
<span class="nc bnc" id="L232" title="All 2 branches missed.">        }else if (moving) {</span>
<span class="nc" id="L233">            currentFrame = walkingAnimation.get(direction).getKeyFrame(stateTime);</span>
        } else {
<span class="nc" id="L235">            currentFrame = idleAnimation.get(direction).getKeyFrame(stateTime);</span>
        }
<span class="nc" id="L237">    }</span>

    /**
     * Returns whether the player's eventHitbox overlaps an object
     * Call getClosestObject to get the nearest
     *
     * @return true if a player is near enough an object to interact with it
     */
    public boolean nearObject() {
<span class="nc bnc" id="L246" title="All 2 branches missed.">        return closestObject != null;</span>
    }

    /**
     * Returns the object that is closest to the player, calculated during move()
     *
     * @return A GameObject that is closest
     */
    public GameObject getClosestObject () {
<span class="nc" id="L255">        return closestObject;</span>
    }

    /**
     * Returns if the player is moving or not
     *
     * @return true if the player is moving
     */
    public boolean isMoving() {
<span class="nc" id="L264">        return moving;</span>
    }

    /**
     * Returns if the player is running or not
     *
     * @return true if the player is moving
     */
    public boolean isRunning() {
<span class="nc" id="L273">        return running;</span>
    }

    /**
     * Sets the player's state to moving or not moving, a not moving character will just display an idle animation
     *
     * @param moving The boolean to set moving to
     */
    public void setMoving(boolean moving) {
<span class="nc" id="L282">        this.moving = moving;</span>
<span class="nc" id="L283">    }</span>


    /**
     * Returns the current frame the player's animation is on
     *
     * @return TextureRegion the frame of the player's animation
     */
    public TextureRegion getCurrentFrame () {
        // Returns the current frame the player animation is on
<span class="nc" id="L293">        return currentFrame;</span>
    }

    /**
     * Sets the objects the player cannot move into as an Array of GameObjects
     *
     * @param collidables An array of GameObjects that the player should collide with
     */
    public void setCollidables (Array&lt;GameObject&gt; collidables) {
<span class="nc" id="L302">        this.collidables = collidables;</span>
<span class="nc" id="L303">    }</span>

    /**
     * Adds a GameObeject to the player's list of collidable objects
     *
     * @param object a GameObject for the player to collide with
     */
    public void addCollidable (GameObject object) {
<span class="nc" id="L311">        this.collidables.add(object);</span>
<span class="nc" id="L312">    }</span>

    /**
     * @return The X coordinate of the player
     */
    public float getX () {
<span class="nc" id="L318">        return sprite.getX();</span>
    }
    /**
     * @return The Y coordinate of the player
     */
    public float getY () {
<span class="nc" id="L324">        return sprite.getY();</span>
    }

    /**
     * @return The X coordinate of the centre point of the player's sprite rectangle
     */
    public float getCentreX () {
<span class="nc" id="L331">        return centreX;</span>
    }
    /**
     * @return The Y coordinate of the centre point of the player's sprite rectangle
     */
    public float getCentreY () {
<span class="nc" id="L337">        return centreY;</span>
    }

    /**
     * @return The Vector3 representation of the bottom left corner of the player's sprite hitbox
     */
    public Vector3 getPosAsVec3() {
<span class="nc" id="L344">        return new Vector3(</span>
<span class="nc" id="L345">                sprite.getX(),</span>
<span class="nc" id="L346">                sprite.getY(),</span>
                0
        );
    }

    /**
     * Sets the x coordinate of the player, updating all 3 hitboxes at once as opposed to just the sprite rectangle
     */
    public void setX (float x) {
<span class="nc" id="L355">        this.sprite.setX(x);</span>
<span class="nc" id="L356">        this.feet.setX(x + 4*scale);</span>
<span class="nc" id="L357">        this.eventHitbox.setX(this.sprite.getX() - (this.eventHitbox.getWidth() - sprite.getWidth()) / 2);</span>
<span class="nc" id="L358">        this.recalcCentre();</span>
<span class="nc" id="L359">    }</span>
    /**
     * Sets the Y coordinate of the player, updating all 3 hitboxes at once as opposed to just the sprite rectangle
     */
    public void setY (float y) {
<span class="nc" id="L364">        this.sprite.setY(y);</span>
<span class="nc" id="L365">        this.feet.setY(y);</span>
<span class="nc" id="L366">        this.eventHitbox.setY(this.sprite.getY() - (this.eventHitbox.getHeight() - sprite.getHeight()) / 2);</span>
<span class="nc" id="L367">        this.recalcCentre();</span>
<span class="nc" id="L368">    }</span>

    /**
     *
     * @param x The X coordinate to set the player to
     * @param y The Y coordinate to set the player to
     */
    public void setPos (float x, float y) {
<span class="nc" id="L376">        this.setX(x);</span>
<span class="nc" id="L377">        this.setY(y);</span>
<span class="nc" id="L378">    }</span>

    /**
     * Set a large rectangle that the player should be kept inside, set to null to set no bounds
     *
     * @param bounds The bounds of the playable map
     */
    public void setBounds (Rectangle bounds) {
        // Set a rectangle that the player should not leave
<span class="nc" id="L387">        this.bounds = bounds;</span>
<span class="nc" id="L388">    }</span>

    /**
     * Returns the euclidian distance from a GameObject to the centre of the player
     *
     * @param object The object to get the distance from
     * @return The distance from the object
     */
    private float distanceFrom (GameObject object) {
<span class="nc" id="L397">        return (float) Math.sqrt((Math.pow((centreX - object.centreX), 2) + Math.pow((centreY - object.centreY), 2)));</span>
    }

    /**
     * Recalculates the centre of the player, useful after moving the player
     */
    private void recalcCentre() {
<span class="nc" id="L404">        centreX = sprite.getX() + sprite.getWidth() / 2;</span>
<span class="nc" id="L405">        centreY = sprite.getY() + sprite.getHeight() / 2;</span>
<span class="nc" id="L406">    }</span>

    /**
     * Sets the player to frozen, a frozen player can be set to ignore keyboard inputs in render
     *
     * @param freeze The value to set frozen to
     */
    public void setFrozen (boolean freeze) {
<span class="nc" id="L414">        this.frozen = freeze;</span>
<span class="nc bnc" id="L415" title="All 2 branches missed.">        if (freeze) {</span>
            // Set to non-moving frame
<span class="nc" id="L417">            currentFrame = idleAnimation.get(direction).getKeyFrame(stateTime);</span>
        }
<span class="nc" id="L419">    }</span>

    /**
     * @return true if the player is frozen
     */
    public boolean isFrozen () {
<span class="nc" id="L425">        return this.frozen;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>